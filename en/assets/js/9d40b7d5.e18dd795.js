"use strict";(self.webpackChunkhook_fetch_docs=self.webpackChunkhook_fetch_docs||[]).push([[4196],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var t=s(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},8626:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"examples/chat-application","title":"Chat Application Example","description":"This example demonstrates how to build a real-time streaming chat application using Hook-Fetch\'s SSE capabilities.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/examples/chat-application.md","sourceDirName":"examples","slug":"/examples/chat-application","permalink":"/hook-fetch/en/docs/examples/chat-application","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Json_Lee","lastUpdatedAt":1751963620000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/hook-fetch/en/docs/best-practices"},"next":{"title":"Frequently Asked Questions","permalink":"/hook-fetch/en/docs/reference/faq"}}');var a=s(4848),o=s(8453);const r={sidebar_position:1},i="Chat Application Example",c={},l=[{value:"Overview",id:"overview",level:2},{value:"React Implementation",id:"react-implementation",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Chat Component",id:"chat-component",level:3},{value:"Styles",id:"styles",level:3},{value:"Vue Implementation",id:"vue-implementation",level:2},{value:"Composable",id:"composable",level:3},{value:"Vue Component",id:"vue-component",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Message Persistence",id:"message-persistence",level:3},{value:"Custom Plugins",id:"custom-plugins",level:3},{value:"Error Recovery",id:"error-recovery",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chat-application-example",children:"Chat Application Example"})}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates how to build a real-time streaming chat application using Hook-Fetch's SSE capabilities."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"We'll build a chat application that:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sends messages to an AI service (like OpenAI)"}),"\n",(0,a.jsx)(n.li,{children:"Receives streaming responses in real-time"}),"\n",(0,a.jsx)(n.li,{children:"Displays messages with typing indicators"}),"\n",(0,a.jsx)(n.li,{children:"Handles errors gracefully"}),"\n",(0,a.jsx)(n.li,{children:"Works in both React and Vue"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"react-implementation",children:"React Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// hooks/useChat.ts\nimport { useState, useCallback } from 'react';\nimport { useHookFetch } from 'hook-fetch/react';\nimport { sseTextDecoderPlugin } from 'hook-fetch/plugins/sse';\nimport hookFetch from 'hook-fetch';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n}\n\nconst chatApi = hookFetch.create({\n  baseURL: 'https://api.openai.com/v1',\n  headers: {\n    'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  },\n  plugins: [\n    sseTextDecoderPlugin({\n      json: true,\n      prefix: 'data: ',\n      doneSymbol: '[DONE]'\n    })\n  ]\n});\n\nexport const useChat = () => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [currentMessage, setCurrentMessage] = useState('');\n  const [isTyping, setIsTyping] = useState(false);\n\n  const { stream, loading, cancel } = useHookFetch({\n    request: (message: string) => chatApi.post('/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        { role: 'user', content: message }\n      ],\n      stream: true,\n      max_tokens: 1000\n    }),\n    onError: (error) => {\n      console.error('Chat error:', error);\n      setIsTyping(false);\n    }\n  });\n\n  const sendMessage = useCallback(async (content: string) => {\n    if (!content.trim() || loading) return;\n\n    // Add user message\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: 'user',\n      content: content.trim(),\n      timestamp: new Date()\n    };\n\n    setMessages(prev => [...prev, userMessage]);\n    setCurrentMessage('');\n    setIsTyping(true);\n\n    try {\n      let assistantContent = '';\n\n      for await (const chunk of stream(content)) {\n        const delta = chunk.result?.choices?.[0]?.delta?.content;\n        if (delta) {\n          assistantContent += delta;\n          setCurrentMessage(assistantContent);\n        }\n      }\n\n      // Add complete assistant message\n      const assistantMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: 'assistant',\n        content: assistantContent,\n        timestamp: new Date()\n      };\n\n      setMessages(prev => [...prev, assistantMessage]);\n      setCurrentMessage('');\n    } catch (error) {\n      console.error('Streaming error:', error);\n    } finally {\n      setIsTyping(false);\n    }\n  }, [messages, loading, stream]);\n\n  return {\n    messages,\n    currentMessage,\n    isTyping,\n    loading,\n    sendMessage,\n    cancel\n  };\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"chat-component",children:"Chat Component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'// components/ChatApp.tsx\nimport React, { useState, useRef, useEffect } from \'react\';\nimport { useChat } from \'../hooks/useChat\';\nimport \'./ChatApp.css\';\n\nconst ChatApp: React.FC = () => {\n  const [input, setInput] = useState(\'\');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const { messages, currentMessage, isTyping, loading, sendMessage, cancel } = useChat();\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \'smooth\' });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, currentMessage]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (input.trim()) {\n      sendMessage(input);\n      setInput(\'\');\n    }\n  };\n\n  return (\n    <div className="chat-app">\n      <div className="chat-header">\n        <h1>AI Chat Assistant</h1>\n        {loading && (\n          <button onClick={cancel} className="cancel-btn">\n            Cancel\n          </button>\n        )}\n      </div>\n\n      <div className="chat-messages">\n        {messages.map((message) => (\n          <div\n            key={message.id}\n            className={`message ${message.role === \'user\' ? \'user\' : \'assistant\'}`}\n          >\n            <div className="message-content">\n              <div className="message-text">{message.content}</div>\n              <div className="message-time">\n                {message.timestamp.toLocaleTimeString()}\n              </div>\n            </div>\n          </div>\n        ))}\n\n        {(isTyping || currentMessage) && (\n          <div className="message assistant">\n            <div className="message-content">\n              <div className="message-text">\n                {currentMessage}\n                {isTyping && <span className="typing-cursor">|</span>}\n              </div>\n            </div>\n          </div>\n        )}\n\n        <div ref={messagesEndRef} />\n      </div>\n\n      <form onSubmit={handleSubmit} className="chat-input">\n        <input\n          type="text"\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          placeholder="Type your message..."\n          disabled={loading}\n          className="input-field"\n        />\n        <button\n          type="submit"\n          disabled={loading || !input.trim()}\n          className="send-btn"\n        >\n          {loading ? \'Sending...\' : \'Send\'}\n        </button>\n      </form>\n    </div>\n  );\n};\n\nexport default ChatApp;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"styles",children:"Styles"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-css",children:"/* components/ChatApp.css */\n.chat-app {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  max-width: 800px;\n  margin: 0 auto;\n  border: 1px solid #e0e0e0;\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.chat-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n  background-color: #f5f5f5;\n  border-bottom: 1px solid #e0e0e0;\n}\n\n.chat-header h1 {\n  margin: 0;\n  font-size: 1.5rem;\n  color: #333;\n}\n\n.cancel-btn {\n  padding: 0.5rem 1rem;\n  background-color: #ff4444;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.chat-messages {\n  flex: 1;\n  overflow-y: auto;\n  padding: 1rem;\n  background-color: #fafafa;\n}\n\n.message {\n  margin-bottom: 1rem;\n  display: flex;\n}\n\n.message.user {\n  justify-content: flex-end;\n}\n\n.message.assistant {\n  justify-content: flex-start;\n}\n\n.message-content {\n  max-width: 70%;\n  padding: 0.75rem 1rem;\n  border-radius: 18px;\n  position: relative;\n}\n\n.message.user .message-content {\n  background-color: #007bff;\n  color: white;\n}\n\n.message.assistant .message-content {\n  background-color: white;\n  border: 1px solid #e0e0e0;\n  color: #333;\n}\n\n.message-text {\n  line-height: 1.4;\n  word-wrap: break-word;\n}\n\n.message-time {\n  font-size: 0.75rem;\n  opacity: 0.7;\n  margin-top: 0.25rem;\n}\n\n.typing-cursor {\n  animation: blink 1s infinite;\n  font-weight: bold;\n}\n\n@keyframes blink {\n  0%, 50% { opacity: 1; }\n  51%, 100% { opacity: 0; }\n}\n\n.chat-input {\n  display: flex;\n  padding: 1rem;\n  background-color: white;\n  border-top: 1px solid #e0e0e0;\n}\n\n.input-field {\n  flex: 1;\n  padding: 0.75rem;\n  border: 1px solid #ccc;\n  border-radius: 20px;\n  margin-right: 0.5rem;\n  outline: none;\n}\n\n.input-field:focus {\n  border-color: #007bff;\n}\n\n.send-btn {\n  padding: 0.75rem 1.5rem;\n  background-color: #007bff;\n  color: white;\n  border: none;\n  border-radius: 20px;\n  cursor: pointer;\n  font-weight: bold;\n}\n\n.send-btn:disabled {\n  background-color: #ccc;\n  cursor: not-allowed;\n}\n\n.send-btn:hover:not(:disabled) {\n  background-color: #0056b3;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"vue-implementation",children:"Vue Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"composable",children:"Composable"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// composables/useChat.ts\nimport { ref, computed } from 'vue';\nimport { useHookFetch } from 'hook-fetch/vue';\nimport { sseTextDecoderPlugin } from 'hook-fetch/plugins/sse';\nimport hookFetch from 'hook-fetch';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n}\n\nconst chatApi = hookFetch.create({\n  baseURL: 'https://api.openai.com/v1',\n  headers: {\n    'Authorization': `Bearer ${import.meta.env.VITE_OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  },\n  plugins: [\n    sseTextDecoderPlugin({\n      json: true,\n      prefix: 'data: ',\n      doneSymbol: '[DONE]'\n    })\n  ]\n});\n\nexport const useChat = () => {\n  const messages = ref<Message[]>([]);\n  const currentMessage = ref('');\n  const isTyping = ref(false);\n\n  const { stream, loading, cancel } = useHookFetch({\n    request: (message: string) => chatApi.post('/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [\n        ...messages.value.map(msg => ({ role: msg.role, content: msg.content })),\n        { role: 'user', content: message }\n      ],\n      stream: true,\n      max_tokens: 1000\n    }),\n    onError: (error) => {\n      console.error('Chat error:', error);\n      isTyping.value = false;\n    }\n  });\n\n  const sendMessage = async (content: string) => {\n    if (!content.trim() || loading.value) return;\n\n    // Add user message\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: 'user',\n      content: content.trim(),\n      timestamp: new Date()\n    };\n\n    messages.value.push(userMessage);\n    currentMessage.value = '';\n    isTyping.value = true;\n\n    try {\n      let assistantContent = '';\n\n      for await (const chunk of stream(content)) {\n        const delta = chunk.result?.choices?.[0]?.delta?.content;\n        if (delta) {\n          assistantContent += delta;\n          currentMessage.value = assistantContent;\n        }\n      }\n\n      // Add complete assistant message\n      const assistantMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        role: 'assistant',\n        content: assistantContent,\n        timestamp: new Date()\n      };\n\n      messages.value.push(assistantMessage);\n      currentMessage.value = '';\n    } catch (error) {\n      console.error('Streaming error:', error);\n    } finally {\n      isTyping.value = false;\n    }\n  };\n\n  return {\n    messages: computed(() => messages.value),\n    currentMessage: computed(() => currentMessage.value),\n    isTyping: computed(() => isTyping.value),\n    loading,\n    sendMessage,\n    cancel\n  };\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"vue-component",children:"Vue Component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-vue",children:'\x3c!-- components/ChatApp.vue --\x3e\n<template>\n  <div class="chat-app">\n    <div class="chat-header">\n      <h1>AI Chat Assistant</h1>\n      <button v-if="loading" @click="cancel" class="cancel-btn">\n        Cancel\n      </button>\n    </div>\n\n    <div ref="messagesContainer" class="chat-messages">\n      <div\n        v-for="message in messages"\n        :key="message.id"\n        :class="[\'message\', message.role]"\n      >\n        <div class="message-content">\n          <div class="message-text">{{ message.content }}</div>\n          <div class="message-time">\n            {{ message.timestamp.toLocaleTimeString() }}\n          </div>\n        </div>\n      </div>\n\n      <div v-if="isTyping || currentMessage" class="message assistant">\n        <div class="message-content">\n          <div class="message-text">\n            {{ currentMessage }}\n            <span v-if="isTyping" class="typing-cursor">|</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <form @submit.prevent="handleSubmit" class="chat-input">\n      <input\n        v-model="input"\n        type="text"\n        placeholder="Type your message..."\n        :disabled="loading"\n        class="input-field"\n      />\n      <button\n        type="submit"\n        :disabled="loading || !input.trim()"\n        class="send-btn"\n      >\n        {{ loading ? \'Sending...\' : \'Send\' }}\n      </button>\n    </form>\n  </div>\n</template>\n\n<script setup lang="ts">\nimport { ref, nextTick, watch } from \'vue\';\nimport { useChat } from \'../composables/useChat\';\n\nconst input = ref(\'\');\nconst messagesContainer = ref<HTMLElement>();\n\nconst { messages, currentMessage, isTyping, loading, sendMessage, cancel } = useChat();\n\nconst scrollToBottom = async () => {\n  await nextTick();\n  if (messagesContainer.value) {\n    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;\n  }\n};\n\nwatch([messages, currentMessage], scrollToBottom);\n\nconst handleSubmit = () => {\n  if (input.value.trim()) {\n    sendMessage(input.value);\n    input.value = \'\';\n  }\n};\n<\/script>\n\n<style scoped>\n/* Same CSS as React version */\n</style>\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,a.jsx)(n.h3,{id:"message-persistence",children:"Message Persistence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// utils/messageStorage.ts\nexport const saveMessages = (messages: Message[]) => {\n  localStorage.setItem('chat-messages', JSON.stringify(messages));\n};\n\nexport const loadMessages = (): Message[] => {\n  const stored = localStorage.getItem('chat-messages');\n  if (stored) {\n    return JSON.parse(stored).map((msg: any) => ({\n      ...msg,\n      timestamp: new Date(msg.timestamp)\n    }));\n  }\n  return [];\n};\n\nexport const clearMessages = () => {\n  localStorage.removeItem('chat-messages');\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"custom-plugins",children:"Custom Plugins"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// plugins/chatLogger.ts\nexport const chatLoggerPlugin = () => ({\n  name: 'chat-logger',\n  async beforeRequest(config) {\n    console.log('Sending chat request:', config.data);\n    return config;\n  },\n  async transformStreamChunk(chunk, config) {\n    if (chunk.result?.choices?.[0]?.delta?.content) {\n      console.log('Received chunk:', chunk.result.choices[0].delta.content);\n    }\n    return chunk;\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"error-recovery",children:"Error Recovery"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// utils/errorRecovery.ts\nexport const retryWithBackoff = async (\n  fn: () => Promise<any>,\n  maxRetries = 3,\n  baseDelay = 1000\n) => {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n\n      const delay = baseDelay * Math.pow(2, i);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"This chat application example demonstrates the power of Hook-Fetch's streaming capabilities for building real-time, interactive applications."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);