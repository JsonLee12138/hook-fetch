"use strict";(self.webpackChunkhook_fetch_docs=self.webpackChunkhook_fetch_docs||[]).push([[997],{1860:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"plugins","title":"Plugin System","description":"Hook-Fetch\'s plugin system is one of its most powerful features, allowing you to inject custom logic into the request lifecycle for highly customizable functionality.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/plugins.md","sourceDirName":".","slug":"/plugins","permalink":"/hook-fetch/en/docs/plugins","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Json_Lee","lastUpdatedAt":1751963620000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/hook-fetch/en/docs/api-reference"},"next":{"title":"Streaming","permalink":"/hook-fetch/en/docs/streaming"}}');var s=r(4848),t=r(8453);const o={sidebar_position:4},l="Plugin System",c={},a=[{value:"Plugin Overview",id:"plugin-overview",level:2},{value:"Plugin Structure",id:"plugin-structure",level:2},{value:"Plugin Lifecycle",id:"plugin-lifecycle",level:2},{value:"Using Plugins",id:"using-plugins",level:2},{value:"Registering Plugins",id:"registering-plugins",level:3},{value:"Plugin Priority",id:"plugin-priority",level:3},{value:"Built-in Plugins",id:"built-in-plugins",level:2},{value:"SSE Text Decoder Plugin",id:"sse-text-decoder-plugin",level:3},{value:"Custom Plugin Examples",id:"custom-plugin-examples",level:2},{value:"1. Authentication Plugin",id:"1-authentication-plugin",level:3},{value:"2. Logger Plugin",id:"2-logger-plugin",level:3},{value:"3. Retry Plugin",id:"3-retry-plugin",level:3},{value:"4. Cache Plugin",id:"4-cache-plugin",level:3},{value:"5. Response Transform Plugin",id:"5-response-transform-plugin",level:3},{value:"Advanced Plugin Development",id:"advanced-plugin-development",level:2},{value:"Plugin with State",id:"plugin-with-state",level:3},{value:"Async Plugin Operations",id:"async-plugin-operations",level:3},{value:"Plugin Best Practices",id:"plugin-best-practices",level:2},{value:"1. Error Handling",id:"1-error-handling",level:3},{value:"2. Performance Considerations",id:"2-performance-considerations",level:3},{value:"3. Plugin Composition",id:"3-plugin-composition",level:3},{value:"Hook Functions Reference",id:"hook-functions-reference",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"plugin-system",children:"Plugin System"})}),"\n",(0,s.jsx)(n.p,{children:"Hook-Fetch's plugin system is one of its most powerful features, allowing you to inject custom logic into the request lifecycle for highly customizable functionality."}),"\n",(0,s.jsx)(n.h2,{id:"plugin-overview",children:"Plugin Overview"}),"\n",(0,s.jsx)(n.p,{children:"A plugin is an object containing hook functions that execute at different stages of the request lifecycle. Plugins can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Modify request configuration"}),"\n",(0,s.jsx)(n.li,{children:"Process response data"}),"\n",(0,s.jsx)(n.li,{children:"Transform streaming data"}),"\n",(0,s.jsx)(n.li,{children:"Handle errors"}),"\n",(0,s.jsx)(n.li,{children:"Perform cleanup operations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"plugin-structure",children:"Plugin Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface HookFetchPlugin<T = unknown, E = unknown, P = unknown, D = unknown> {\n  name: string;                    // Plugin name (required)\n  priority?: number;               // Priority (optional, default 0)\n  beforeRequest?: BeforeRequestHandler<E, P, D>;\n  afterResponse?: AfterResponseHandler<T, E, P, D>;\n  beforeStream?: BeforeStreamHandler<E, P, D>;\n  transformStreamChunk?: TransformStreamChunkHandler<E, P, D>;\n  onError?: OnErrorHandler<E, P, D>;\n  onFinally?: OnFinallyHandler<E, P, D>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"plugin-lifecycle",children:"Plugin Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"Plugins execute in the following order:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"beforeRequest"})," - Before request is sent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"beforeStream"})," - Before stream processing (stream requests only)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"transformStreamChunk"})," - Transform stream chunks (stream requests only)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"afterResponse"})," - After response is received"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"onError"})," - Error handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"onFinally"})," - Final cleanup"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-plugins",children:"Using Plugins"}),"\n",(0,s.jsx)(n.h3,{id:"registering-plugins",children:"Registering Plugins"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Register during instance creation\nconst api = hookFetch.create({\n  baseURL: 'https://api.example.com',\n  plugins: [myPlugin(), anotherPlugin()]\n});\n\n// Or use the use method\napi.use(myPlugin());\n"})}),"\n",(0,s.jsx)(n.h3,{id:"plugin-priority",children:"Plugin Priority"}),"\n",(0,s.jsx)(n.p,{children:"Plugins execute by priority, with lower numbers having higher priority:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const highPriorityPlugin = {\n  name: 'high-priority',\n  priority: 1,\n  beforeRequest(config) {\n    // Executes first\n    return config;\n  }\n};\n\nconst lowPriorityPlugin = {\n  name: 'low-priority',\n  priority: 10,\n  beforeRequest(config) {\n    // Executes later\n    return config;\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"built-in-plugins",children:"Built-in Plugins"}),"\n",(0,s.jsx)(n.h3,{id:"sse-text-decoder-plugin",children:"SSE Text Decoder Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Hook-Fetch provides a built-in SSE (Server-Sent Events) text decoder plugin:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { sseTextDecoderPlugin } from 'hook-fetch/plugins/sse';\n\nconst api = hookFetch.create({\n  plugins: [\n    sseTextDecoderPlugin({\n      json: true,                 // Auto-parse JSON\n      prefix: 'data: ',          // Remove prefix\n      splitSeparator: '\\n\\n',    // Event separator\n      doneSymbol: '[DONE]'       // End marker\n    })\n  ]\n});\n\n// Use SSE\nfor await (const chunk of api.get('/sse-endpoint').stream()) {\n  console.log(chunk.result); // Auto-parsed data\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"custom-plugin-examples",children:"Custom Plugin Examples"}),"\n",(0,s.jsx)(n.h3,{id:"1-authentication-plugin",children:"1. Authentication Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Automatically add authentication headers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const authPlugin = (getToken: () => string) => ({\n  name: 'auth',\n  priority: 1,\n  async beforeRequest(config) {\n    const token = getToken();\n    if (token) {\n      config.headers = new Headers(config.headers);\n      config.headers.set('Authorization', `Bearer ${token}`);\n    }\n    return config;\n  }\n});\n\n// Usage\nconst api = hookFetch.create({\n  plugins: [authPlugin(() => localStorage.getItem('token') || '')]\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-logger-plugin",children:"2. Logger Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Log requests and responses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const loggerPlugin = () => ({\n  name: 'logger',\n  async beforeRequest(config) {\n    console.log(`[${config.method}] ${config.url}`);\n    return config;\n  },\n  async afterResponse(context, config) {\n    console.log(`[${config.method}] ${config.url} - ${context.response.status}`);\n    return context;\n  },\n  async onError(error, config) {\n    console.error(`[${config.method}] ${config.url} - Error:`, error.message);\n    return error;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-retry-plugin",children:"3. Retry Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Automatically retry failed requests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const retryPlugin = (maxRetries = 3, delay = 1000) => ({\n  name: 'retry',\n  async onError(error, config) {\n    const retryCount = config.extra?.retryCount || 0;\n\n    if (retryCount < maxRetries && error.response?.status >= 500) {\n      // Delay before retry\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Increment retry count\n      config.extra = { ...config.extra, retryCount: retryCount + 1 };\n\n      // Make new request\n      const newRequest = hookFetch(config.url, config);\n      return newRequest;\n    }\n\n    return error;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-cache-plugin",children:"4. Cache Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Cache GET request responses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const cachePlugin = (ttl = 5 * 60 * 1000) => {\n  const cache = new Map();\n\n  return {\n    name: 'cache',\n    async beforeRequest(config) {\n      if (config.method === 'GET') {\n        const key = `${config.url}?${new URLSearchParams(config.params).toString()}`;\n        const cached = cache.get(key);\n\n        if (cached && Date.now() - cached.timestamp < ttl) {\n          // Return cached response\n          return Promise.resolve(cached.response);\n        }\n      }\n      return config;\n    },\n    async afterResponse(context, config) {\n      if (config.method === 'GET') {\n        const key = `${config.url}?${new URLSearchParams(config.params).toString()}`;\n        cache.set(key, {\n          response: context.result,\n          timestamp: Date.now()\n        });\n      }\n      return context;\n    }\n  };\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-response-transform-plugin",children:"5. Response Transform Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Transform response data format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const responseTransformPlugin = () => ({\n  name: 'response-transform',\n  async afterResponse(context, config) {\n    if (context.responseType === 'json' && context.result) {\n      // Transform API response format\n      if (context.result.code === 200) {\n        context.result = context.result.data;\n      } else {\n        throw new Error(context.result.message);\n      }\n    }\n    return context;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-plugin-development",children:"Advanced Plugin Development"}),"\n",(0,s.jsx)(n.h3,{id:"plugin-with-state",children:"Plugin with State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const statisticsPlugin = () => {\n  let requestCount = 0;\n  let errorCount = 0;\n\n  return {\n    name: 'statistics',\n    async beforeRequest(config) {\n      requestCount++;\n      console.log(`Total requests: ${requestCount}`);\n      return config;\n    },\n    async onError(error, config) {\n      errorCount++;\n      console.log(`Total errors: ${errorCount}`);\n      return error;\n    },\n    getStats() {\n      return { requestCount, errorCount };\n    }\n  };\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"async-plugin-operations",children:"Async Plugin Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const asyncPlugin = () => ({\n  name: 'async-plugin',\n  async beforeRequest(config) {\n    // Async operation\n    const signature = await generateSignature(config);\n    config.headers = new Headers(config.headers);\n    config.headers.set('X-Signature', signature);\n    return config;\n  },\n  async afterResponse(context, config) {\n    // Async response processing\n    await logToAnalytics(config.url, context.response.status);\n    return context;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"plugin-best-practices",children:"Plugin Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-error-handling",children:"1. Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Always handle errors gracefully in plugins:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const safePlugin = () => ({\n  name: 'safe-plugin',\n  async beforeRequest(config) {\n    try {\n      // Plugin logic\n      return config;\n    } catch (error) {\n      console.error('Plugin error:', error);\n      return config; // Return original config on error\n    }\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-performance-considerations",children:"2. Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:"Avoid blocking operations in plugins:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const performantPlugin = () => ({\n  name: 'performant-plugin',\n  async beforeRequest(config) {\n    // Use non-blocking operations\n    setImmediate(() => {\n      // Background task\n      updateMetrics(config);\n    });\n    return config;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-plugin-composition",children:"3. Plugin Composition"}),"\n",(0,s.jsx)(n.p,{children:"Create reusable plugin factories:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const createApiPlugin = (options: ApiPluginOptions) => ({\n  name: 'api-plugin',\n  ...createAuthBehavior(options.auth),\n  ...createRetryBehavior(options.retry),\n  ...createCacheBehavior(options.cache)\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"hook-functions-reference",children:"Hook Functions Reference"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"beforeRequest"}),": Modify request configuration before sending"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"afterResponse"}),": Process response data after receiving"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"beforeStream"}),": Initialize or transform stream before processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transformStreamChunk"}),": Process streaming data chunks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onError"}),": Handle request errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onFinally"}),": Cleanup operations after request completion"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"All lifecycle hooks support both synchronous and asynchronous operations. Each hook function receives the current configuration object for context-aware processing."}),"\n",(0,s.jsx)(n.p,{children:"This plugin system provides powerful extensibility for Hook-Fetch, allowing you to customize request behavior for any use case."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);