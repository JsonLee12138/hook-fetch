"use strict";(self.webpackChunkhook_fetch_docs=self.webpackChunkhook_fetch_docs||[]).push([[5150],{586:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"best-practices","title":"Best Practices","description":"This guide covers recommended practices and patterns for using Hook-Fetch effectively in your projects.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/hook-fetch/en/docs/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Json_Lee","lastUpdatedAt":1751963620000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Framework Integration","permalink":"/hook-fetch/en/docs/framework-integration"},"next":{"title":"Chat Application Example","permalink":"/hook-fetch/en/docs/examples/chat-application"}}');var s=r(4489),i=r(3237);const o={sidebar_position:7},a="Best Practices",c={},l=[{value:"Project Structure",id:"project-structure",level:2},{value:"Organizing API Calls",id:"organizing-api-calls",level:3},{value:"Service Layer Pattern",id:"service-layer-pattern",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Global Error Handling",id:"global-error-handling",level:3},{value:"Typed Error Handling",id:"typed-error-handling",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Request Deduplication",id:"request-deduplication",level:3},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Security",id:"security",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Request Signing",id:"request-signing",level:3},{value:"Testing",id:"testing",level:2},{value:"Mocking Requests",id:"mocking-requests",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"TypeScript Best Practices",id:"typescript-best-practices",level:2},{value:"Type-Safe API Definitions",id:"type-safe-api-definitions",level:3},{value:"Generic Request Functions",id:"generic-request-functions",level:3},{value:"Environment Configuration",id:"environment-configuration",level:2},{value:"Environment-Specific Settings",id:"environment-specific-settings",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers recommended practices and patterns for using Hook-Fetch effectively in your projects."}),"\n",(0,s.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.h3,{id:"organizing-api-calls",children:"Organizing API Calls"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// api/client.ts\nimport hookFetch from 'hook-fetch';\nimport { authPlugin } from './plugins/auth';\nimport { loggerPlugin } from './plugins/logger';\nimport { retryPlugin } from './plugins/retry';\n\nexport const apiClient = hookFetch.create({\n  baseURL: process.env.REACT_APP_API_URL || 'https://api.example.com',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  plugins: [\n    authPlugin(),\n    loggerPlugin(),\n    retryPlugin({ maxRetries: 3 })\n  ]\n});\n\n// api/users.ts\nimport { apiClient } from './client';\n\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport const userApi = {\n  getUser: (id: string) => apiClient.get<User>(`/users/${id}`),\n  createUser: (data: Omit<User, 'id'>) => apiClient.post<User>('/users', data),\n  updateUser: (id: string, data: Partial<User>) => apiClient.put<User>(`/users/${id}`, data),\n  deleteUser: (id: string) => apiClient.delete(`/users/${id}`)\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"service-layer-pattern",children:"Service Layer Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// services/UserService.ts\nimport { userApi } from '../api/users';\n\nexport class UserService {\n  static async getUser(id: string): Promise<User> {\n    try {\n      const response = await userApi.getUser(id).json();\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to fetch user: ${error.message}`);\n    }\n  }\n\n  static async createUser(userData: Omit<User, 'id'>): Promise<User> {\n    try {\n      const response = await userApi.createUser(userData).json();\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to create user: ${error.message}`);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"global-error-handling",children:"Global Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// plugins/errorHandler.ts\nimport { HookFetchPlugin } from 'hook-fetch';\n\nexport const errorHandlerPlugin = (): HookFetchPlugin => ({\n  name: 'error-handler',\n  priority: 1,\n  async onError(error, config) {\n    // Log error\n    console.error(`API Error [${config.method}] ${config.url}:`, error);\n\n    // Handle specific error types\n    if (error.response?.status === 401) {\n      // Handle unauthorized\n      window.location.href = '/login';\n      return;\n    }\n\n    if (error.response?.status === 403) {\n      // Handle forbidden\n      throw new Error('Access denied');\n    }\n\n    if (error.response?.status >= 500) {\n      // Handle server errors\n      throw new Error('Server error occurred');\n    }\n\n    // Re-throw for other errors\n    throw error;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"typed-error-handling",children:"Typed Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// types/errors.ts\nexport interface ApiError {\n  code: string;\n  message: string;\n  details?: any;\n}\n\nexport class ApiException extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'ApiException';\n  }\n}\n\n// plugins/typedErrorHandler.ts\nexport const typedErrorHandlerPlugin = (): HookFetchPlugin => ({\n  name: 'typed-error-handler',\n  async onError(error, config) {\n    if (error.response) {\n      const errorData = await error.response.json();\n      throw new ApiException(\n        errorData.code || 'UNKNOWN_ERROR',\n        errorData.message || 'An error occurred',\n        errorData.details\n      );\n    }\n    throw error;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"request-deduplication",children:"Request Deduplication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// utils/requestDeduplication.ts\nconst pendingRequests = new Map<string, Promise<any>>();\n\nexport const deduplicationPlugin = (): HookFetchPlugin => ({\n  name: 'deduplication',\n  async beforeRequest(config) {\n    if (config.method === 'GET') {\n      const key = `${config.url}?${JSON.stringify(config.params)}`;\n\n      if (pendingRequests.has(key)) {\n        return pendingRequests.get(key);\n      }\n\n      const requestPromise = fetch(config.url, config);\n      pendingRequests.set(key, requestPromise);\n\n      requestPromise.finally(() => {\n        pendingRequests.delete(key);\n      });\n\n      return requestPromise;\n    }\n    return config;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// plugins/cache.ts\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n  ttl: number;\n}\n\nexport const cachePlugin = (defaultTtl = 5 * 60 * 1000): HookFetchPlugin => {\n  const cache = new Map<string, CacheEntry>();\n\n  return {\n    name: 'cache',\n    async beforeRequest(config) {\n      if (config.method === 'GET') {\n        const key = `${config.url}?${JSON.stringify(config.params)}`;\n        const cached = cache.get(key);\n\n        if (cached && Date.now() - cached.timestamp < cached.ttl) {\n          return Promise.resolve(cached.data);\n        }\n      }\n      return config;\n    },\n    async afterResponse(context, config) {\n      if (config.method === 'GET') {\n        const key = `${config.url}?${JSON.stringify(config.params)}`;\n        const ttl = config.extra?.cacheTtl || defaultTtl;\n\n        cache.set(key, {\n          data: context.result,\n          timestamp: Date.now(),\n          ttl\n        });\n      }\n      return context;\n    }\n  };\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,s.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// plugins/auth.ts\nexport const authPlugin = (): HookFetchPlugin => ({\n  name: 'auth',\n  priority: 1,\n  async beforeRequest(config) {\n    const token = localStorage.getItem('accessToken');\n\n    if (token) {\n      config.headers = new Headers(config.headers);\n      config.headers.set('Authorization', `Bearer ${token}`);\n    }\n\n    return config;\n  },\n  async onError(error, config) {\n    if (error.response?.status === 401) {\n      // Token expired, try to refresh\n      try {\n        const refreshToken = localStorage.getItem('refreshToken');\n        if (refreshToken) {\n          const response = await fetch('/auth/refresh', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ refreshToken })\n          });\n\n          if (response.ok) {\n            const { accessToken } = await response.json();\n            localStorage.setItem('accessToken', accessToken);\n\n            // Retry original request\n            config.headers.set('Authorization', `Bearer ${accessToken}`);\n            return hookFetch(config.url, config);\n          }\n        }\n      } catch (refreshError) {\n        // Refresh failed, redirect to login\n        localStorage.removeItem('accessToken');\n        localStorage.removeItem('refreshToken');\n        window.location.href = '/login';\n      }\n    }\n    return error;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"request-signing",children:"Request Signing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// plugins/requestSigning.ts\nimport { createHmac } from 'crypto';\n\nexport const requestSigningPlugin = (secretKey: string): HookFetchPlugin => ({\n  name: 'request-signing',\n  async beforeRequest(config) {\n    const timestamp = Date.now().toString();\n    const method = config.method.toUpperCase();\n    const url = config.url;\n    const body = config.data ? JSON.stringify(config.data) : '';\n\n    const stringToSign = `${method}\\n${url}\\n${timestamp}\\n${body}`;\n    const signature = createHmac('sha256', secretKey)\n      .update(stringToSign)\n      .digest('hex');\n\n    config.headers = new Headers(config.headers);\n    config.headers.set('X-Timestamp', timestamp);\n    config.headers.set('X-Signature', signature);\n\n    return config;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(n.h3,{id:"mocking-requests",children:"Mocking Requests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// __tests__/mocks/api.ts\nimport { jest } from '@jest/globals';\n\nexport const mockApiClient = {\n  get: jest.fn(),\n  post: jest.fn(),\n  put: jest.fn(),\n  delete: jest.fn(),\n  use: jest.fn()\n};\n\n// __tests__/UserService.test.ts\nimport { UserService } from '../services/UserService';\nimport { mockApiClient } from './mocks/api';\n\njest.mock('../api/client', () => ({\n  apiClient: mockApiClient\n}));\n\ndescribe('UserService', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should fetch user successfully', async () => {\n    const mockUser = { id: '1', name: 'John', email: 'john@example.com' };\n    mockApiClient.get.mockReturnValue({\n      json: jest.fn().mockResolvedValue({ data: mockUser })\n    });\n\n    const result = await UserService.getUser('1');\n\n    expect(mockApiClient.get).toHaveBeenCalledWith('/users/1');\n    expect(result).toEqual(mockUser);\n  });\n\n  test('should handle error when fetching user fails', async () => {\n    mockApiClient.get.mockReturnValue({\n      json: jest.fn().mockRejectedValue(new Error('Network error'))\n    });\n\n    await expect(UserService.getUser('1')).rejects.toThrow('Failed to fetch user');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// __tests__/integration/api.test.ts\nimport { apiClient } from '../api/client';\nimport { setupServer } from 'msw/node';\nimport { rest } from 'msw';\n\nconst server = setupServer(\n  rest.get('/users/:id', (req, res, ctx) => {\n    return res(\n      ctx.json({\n        data: { id: req.params.id, name: 'John', email: 'john@example.com' }\n      })\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('API Integration', () => {\n  test('should make real HTTP request', async () => {\n    const response = await apiClient.get('/users/1').json();\n\n    expect(response.data).toEqual({\n      id: '1',\n      name: 'John',\n      email: 'john@example.com'\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"typescript-best-practices",children:"TypeScript Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"type-safe-api-definitions",children:"Type-Safe API Definitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// types/api.ts\nexport interface ApiResponse<T> {\n  data: T;\n  message: string;\n  success: boolean;\n}\n\nexport interface PaginatedResponse<T> extends ApiResponse<T[]> {\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n  };\n}\n\n// api/typed-client.ts\nclass TypedApiClient {\n  private client = hookFetch.create({\n    baseURL: process.env.API_URL\n  });\n\n  async get<T>(url: string, params?: Record<string, any>): Promise<ApiResponse<T>> {\n    const response = await this.client.get(url, params).json();\n    return response as ApiResponse<T>;\n  }\n\n  async post<T, D = any>(url: string, data?: D): Promise<ApiResponse<T>> {\n    const response = await this.client.post(url, data).json();\n    return response as ApiResponse<T>;\n  }\n\n  async getPaginated<T>(\n    url: string,\n    params?: Record<string, any>\n  ): Promise<PaginatedResponse<T>> {\n    const response = await this.client.get(url, params).json();\n    return response as PaginatedResponse<T>;\n  }\n}\n\nexport const typedApiClient = new TypedApiClient();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generic-request-functions",children:"Generic Request Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// utils/requests.ts\nexport async function fetchWithRetry<T>(\n  requestFn: () => Promise<T>,\n  maxRetries = 3,\n  delay = 1000\n): Promise<T> {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await requestFn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n\n// Usage\nconst user = await fetchWithRetry(\n  () => apiClient.get<User>('/users/1').json(),\n  3,\n  1000\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"environment-specific-settings",children:"Environment-Specific Settings"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// config/api.ts\ninterface ApiConfig {\n  baseURL: string;\n  timeout: number;\n  retryAttempts: number;\n  enableLogging: boolean;\n}\n\nconst configs: Record<string, ApiConfig> = {\n  development: {\n    baseURL: 'http://localhost:3000/api',\n    timeout: 30000,\n    retryAttempts: 3,\n    enableLogging: true\n  },\n  production: {\n    baseURL: 'https://api.example.com',\n    timeout: 10000,\n    retryAttempts: 1,\n    enableLogging: false\n  }\n};\n\nexport const apiConfig = configs[process.env.NODE_ENV] || configs.development;\n\n// client.ts\nimport { apiConfig } from './config/api';\n\nexport const apiClient = hookFetch.create({\n  baseURL: apiConfig.baseURL,\n  timeout: apiConfig.timeout,\n  plugins: [\n    ...(apiConfig.enableLogging ? [loggerPlugin()] : []),\n    retryPlugin({ maxRetries: apiConfig.retryAttempts })\n  ]\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"These best practices will help you build robust, maintainable, and performant applications with Hook-Fetch."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},3237:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(4349);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);