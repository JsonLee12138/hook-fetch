"use strict";(self.webpackChunkhook_fetch_docs=self.webpackChunkhook_fetch_docs||[]).push([[8338],{7741:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"framework-integration","title":"Framework Integration","description":"Hook-Fetch provides specialized integration support for mainstream frontend frameworks, allowing you to better use streaming data processing and request management features in React, Vue, and other frameworks.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/framework-integration.md","sourceDirName":".","slug":"/framework-integration","permalink":"/hook-fetch/en/docs/framework-integration","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Json_Lee","lastUpdatedAt":1751963620000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Streaming","permalink":"/hook-fetch/en/docs/streaming"},"next":{"title":"Best Practices","permalink":"/hook-fetch/en/docs/best-practices"}}');var r=t(4848),o=t(8453);const a={sidebar_position:6},i="Framework Integration",c={},l=[{value:"React Integration",id:"react-integration",level:2},{value:"Installation and Import",id:"installation-and-import",level:3},{value:"useHookFetch Hook",id:"usehookfetch-hook",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Streaming Chat Component",id:"streaming-chat-component",level:3},{value:"Vue Integration",id:"vue-integration",level:2},{value:"Installation and Import",id:"installation-and-import-1",level:3},{value:"useHookFetch Composable",id:"usehookfetch-composable",level:3},{value:"Basic Usage",id:"basic-usage-1",level:3},{value:"Vue Streaming Chat Component",id:"vue-streaming-chat-component",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Error Handling",id:"1-error-handling",level:3},{value:"2. Loading States",id:"2-loading-states",level:3},{value:"3. Request Cancellation",id:"3-request-cancellation",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"framework-integration",children:"Framework Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Hook-Fetch provides specialized integration support for mainstream frontend frameworks, allowing you to better use streaming data processing and request management features in React, Vue, and other frameworks."}),"\n",(0,r.jsx)(n.h2,{id:"react-integration",children:"React Integration"}),"\n",(0,r.jsx)(n.h3,{id:"installation-and-import",children:"Installation and Import"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useHookFetch } from 'hook-fetch/react';\nimport hookFetch from 'hook-fetch';\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usehookfetch-hook",children:"useHookFetch Hook"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useHookFetch"})," is a Hook designed specifically for React, providing state management, error handling, and lifecycle management."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface UseHookFetchOptions<Q> {\n  request: Q;                    // Request function\n  onError?: (error: Error) => void; // Error handling callback\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import React from 'react';\nimport { useHookFetch } from 'hook-fetch/react';\nimport hookFetch from 'hook-fetch';\n\nconst api = hookFetch.create({\n  baseURL: 'https://api.example.com'\n});\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const {\n    request,\n    loading,\n    cancel,\n    text,\n    stream\n  } = useHookFetch({\n    request: (id: string) => api.get(`/users/${id}`),\n    onError: (error) => console.error('Request failed:', error)\n  });\n\n  const [userData, setUserData] = React.useState(null);\n\n  const loadUser = async () => {\n    try {\n      const data = await request(userId).json();\n      setUserData(data);\n    } catch (error) {\n      console.error('Failed to load user:', error);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={loadUser} disabled={loading}>\n        {loading ? 'Loading...' : 'Load User'}\n      </button>\n      <button onClick={cancel}>Cancel</button>\n      {userData && <div>{JSON.stringify(userData)}</div>}\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"streaming-chat-component",children:"Streaming Chat Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import React, { useState, useEffect } from 'react';\nimport { useHookFetch } from 'hook-fetch/react';\nimport { sseTextDecoderPlugin } from 'hook-fetch/plugins/sse';\n\nconst chatApi = hookFetch.create({\n  baseURL: 'https://api.openai.com/v1',\n  headers: {\n    'Authorization': 'Bearer your-api-key',\n    'Content-Type': 'application/json'\n  },\n  plugins: [\n    sseTextDecoderPlugin({\n      json: true,\n      prefix: 'data: ',\n      doneSymbol: '[DONE]'\n    })\n  ]\n});\n\nfunction StreamingChat() {\n  const [messages, setMessages] = useState<string[]>([]);\n  const [currentMessage, setCurrentMessage] = useState('');\n  const [input, setInput] = useState('');\n\n  const { stream, loading, cancel } = useHookFetch({\n    request: (message: string) => chatApi.post('/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{ role: 'user', content: message }],\n      stream: true\n    }),\n    onError: (error) => {\n      console.error('Chat error:', error);\n      setCurrentMessage('Error: Failed to get response');\n    }\n  });\n\n  const sendMessage = async () => {\n    if (!input.trim() || loading) return;\n\n    const userMessage = input;\n    setInput('');\n    setMessages(prev => [...prev, `User: ${userMessage}`]);\n    setCurrentMessage('');\n\n    try {\n      for await (const chunk of stream(userMessage)) {\n        const delta = chunk.result?.choices?.[0]?.delta?.content;\n        if (delta) {\n          setCurrentMessage(prev => prev + delta);\n        }\n      }\n\n      // Add message to history when streaming is complete\n      setMessages(prev => [...prev, `AI: ${currentMessage}`]);\n      setCurrentMessage('');\n    } catch (error) {\n      console.error('Streaming error:', error);\n    }\n  };\n\n  return (\n    <div className=\"chat-container\">\n      <div className=\"messages\">\n        {messages.map((msg, index) => (\n          <div key={index} className=\"message\">{msg}</div>\n        ))}\n        {currentMessage && (\n          <div className=\"message streaming\">\n            AI: {currentMessage}\n            <span className=\"cursor\">|</span>\n          </div>\n        )}\n      </div>\n\n      <div className=\"input-area\">\n        <input\n          type=\"text\"\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}\n          placeholder=\"Type your message...\"\n          disabled={loading}\n        />\n        <button onClick={sendMessage} disabled={loading || !input.trim()}>\n          {loading ? 'Sending...' : 'Send'}\n        </button>\n        {loading && <button onClick={cancel}>Cancel</button>}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"vue-integration",children:"Vue Integration"}),"\n",(0,r.jsx)(n.h3,{id:"installation-and-import-1",children:"Installation and Import"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useHookFetch } from 'hook-fetch/vue';\nimport hookFetch from 'hook-fetch';\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usehookfetch-composable",children:"useHookFetch Composable"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useHookFetch"})," is a composable function designed for Vue 3, providing reactive state management."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface UseHookFetchOptions<Q> {\n  request: Q;                    // Request function\n  onError?: (error: Error) => void; // Error handling callback\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vue",children:"<template>\n  <div>\n    <button @click=\"loadUser\" :disabled=\"loading\">\n      {{ loading ? 'Loading...' : 'Load User' }}\n    </button>\n    <button @click=\"cancel\">Cancel</button>\n    <div v-if=\"userData\">{{ userData }}</div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport { useHookFetch } from 'hook-fetch/vue';\nimport hookFetch from 'hook-fetch';\n\nconst api = hookFetch.create({\n  baseURL: 'https://api.example.com'\n});\n\nconst userData = ref(null);\n\nconst { request, loading, cancel } = useHookFetch({\n  request: (id: string) => api.get(`/users/${id}`),\n  onError: (error) => console.error('Request failed:', error)\n});\n\nconst loadUser = async () => {\n  try {\n    const data = await request('123').json();\n    userData.value = data;\n  } catch (error) {\n    console.error('Failed to load user:', error);\n  }\n};\n<\/script>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"vue-streaming-chat-component",children:"Vue Streaming Chat Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vue",children:"<template>\n  <div class=\"chat-container\">\n    <div class=\"messages\">\n      <div v-for=\"(msg, index) in messages\" :key=\"index\" class=\"message\">\n        {{ msg }}\n      </div>\n      <div v-if=\"currentMessage\" class=\"message streaming\">\n        AI: {{ currentMessage }}\n        <span class=\"cursor\">|</span>\n      </div>\n    </div>\n\n    <div class=\"input-area\">\n      <input\n        v-model=\"input\"\n        @keyup.enter=\"sendMessage\"\n        placeholder=\"Type your message...\"\n        :disabled=\"loading\"\n      />\n      <button @click=\"sendMessage\" :disabled=\"loading || !input.trim()\">\n        {{ loading ? 'Sending...' : 'Send' }}\n      </button>\n      <button v-if=\"loading\" @click=\"cancel\">Cancel</button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport { useHookFetch } from 'hook-fetch/vue';\nimport { sseTextDecoderPlugin } from 'hook-fetch/plugins/sse';\n\nconst chatApi = hookFetch.create({\n  baseURL: 'https://api.openai.com/v1',\n  headers: {\n    'Authorization': 'Bearer your-api-key',\n    'Content-Type': 'application/json'\n  },\n  plugins: [\n    sseTextDecoderPlugin({\n      json: true,\n      prefix: 'data: ',\n      doneSymbol: '[DONE]'\n    })\n  ]\n});\n\nconst messages = ref<string[]>([]);\nconst currentMessage = ref('');\nconst input = ref('');\n\nconst { stream, loading, cancel } = useHookFetch({\n  request: (message: string) => chatApi.post('/chat/completions', {\n    model: 'gpt-3.5-turbo',\n    messages: [{ role: 'user', content: message }],\n    stream: true\n  }),\n  onError: (error) => {\n    console.error('Chat error:', error);\n    currentMessage.value = 'Error: Failed to get response';\n  }\n});\n\nconst sendMessage = async () => {\n  if (!input.value.trim() || loading.value) return;\n\n  const userMessage = input.value;\n  input.value = '';\n  messages.value.push(`User: ${userMessage}`);\n  currentMessage.value = '';\n\n  try {\n    for await (const chunk of stream(userMessage)) {\n      const delta = chunk.result?.choices?.[0]?.delta?.content;\n      if (delta) {\n        currentMessage.value += delta;\n      }\n    }\n\n    // Add message to history when streaming is complete\n    messages.value.push(`AI: ${currentMessage.value}`);\n    currentMessage.value = '';\n  } catch (error) {\n    console.error('Streaming error:', error);\n  }\n};\n<\/script>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-error-handling",children:"1. Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// React\nconst { request, loading } = useHookFetch({\n  request: (id: string) => api.get(`/users/${id}`),\n  onError: (error) => {\n    // Global error handling\n    if (error.response?.status === 401) {\n      // Handle unauthorized\n      redirectToLogin();\n    }\n  }\n});\n\n// Vue\nconst { request, loading } = useHookFetch({\n  request: (id: string) => api.get(`/users/${id}`),\n  onError: (error) => {\n    // Global error handling\n    if (error.response?.status === 401) {\n      // Handle unauthorized\n      await router.push('/login');\n    }\n  }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-loading-states",children:"2. Loading States"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// React\nfunction DataComponent() {\n  const { request, loading } = useHookFetch({\n    request: () => api.get('/data')\n  });\n\n  return (\n    <div>\n      {loading && <div>Loading...</div>}\n      {/* Component content */}\n    </div>\n  );\n}\n\n// Vue\n<template>\n  <div>\n    <div v-if=\"loading\">Loading...</div>\n    \x3c!-- Component content --\x3e\n  </div>\n</template>\n\n<script setup>\nconst { request, loading } = useHookFetch({\n  request: () => api.get('/data')\n});\n<\/script>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-request-cancellation",children:"3. Request Cancellation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// React\nuseEffect(() => {\n  return () => {\n    // Cancel request when component unmounts\n    cancel();\n  };\n}, [cancel]);\n\n// Vue\nonUnmounted(() => {\n  // Cancel request when component unmounts\n  cancel();\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"The framework integration makes it easy to use Hook-Fetch's powerful features in modern frontend applications while maintaining clean, reactive code patterns."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);